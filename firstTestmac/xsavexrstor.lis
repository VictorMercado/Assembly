     1                                  ;****************************************************************************************************************************
     2                                  ;Program name: "Xsave Example".  This program demonstrates the use of assembly instructions xsave and xrstor to back up and *
     3                                  ;restore values in the state compnents of an X86 processor.  Copyright (C) 2020  Floyd Holliday                             *
     4                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     5                                  ;version 3 as published by the Free Software Foundation.                                                                    *
     6                                  ;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     7                                  ;warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     8                                  ;A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.                           *
     9                                  ;****************************************************************************************************************************
    10                                  ;
    11                                  ;
    12                                  ;
    13                                  ;
    14                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
    15                                  ;Author information
    16                                  ; Author name: Floyd Holliday
    17                                  ;  Author email: holliday@fullerton.edu
    18                                  ;
    19                                  ;Program information
    20                                  ;  Program name: Xsave Example
    21                                  ;  Programming languages: One modules in C++, one module in X86-64, and one module in Bash.
    22                                  ;  Date program began: 2020-Apr-12
    23                                  ;  Date of last update: 2020-Feb-15
    24                                  ;  Files in this program: sxavexrstordriver.cpp, xsavexrstor.asm, run.sh
    25                                  ;  Status: This program was tested by the author many times.
    26                                  ;  Purpose: The purpsoe of this program is to call xsavexrstormain
    27                                  ;
    28                                  ;This file
    29                                  ;  Name: xsavexrstor.asm
    30                                  ;  Language: X86
    31                                  ;  Syntax: Intel
    32                                  ;  Assemble: nasm -f elf64 -l xsavexrstor.lis -o xsavexrstor.o xsavexrstor.asm
    33                                  ;  Purpose: Demonstrate how to use xsave and xrstor.  Show that data backed up by xsave are really recovered by xrstor.
    34                                  ;  Limitations: The two instructions back component data (FPU,SSE,AVX).  They do not back up GPRs.
    35                                  ;
    36                                  ;References and credits:
    37                                  ;  Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3B, Chapter 13. [A free ebook at the Intel website.] 
    38                                  ;
    39                                  ;
    40                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
    41                                  ;
    42                                  ;===== Begin code area ======================================================================================================
    43                                  
    44                                  extern _printf                                     ;External C++ function for writing to standard output device
    45                                  
    46                                  global _xsavexrstormain                            ;This makes xsavexrstormain callable by functions outside of this file.
    47                                  
    48                                  segment .data                                     ;Place initialized data here
    49                                  
    50 00000000 57656C636F6D652074-     welcomemessage db "Welcome to xsave and xrstor.", 10, 0
    50 00000009 6F2078736176652061-
    50 00000012 6E6420787273746F72-
    50 0000001B 2E0A00             
    51                                  
    52 0000001E 546869732070726F67-     intentmessage db "This program will demonstrate the use of xsave and xrstor.", 10, 0
    52 00000027 72616D2077696C6C20-
    52 00000030 64656D6F6E73747261-
    52 00000039 746520746865207573-
    52 00000042 65206F662078736176-
    52 0000004B 6520616E6420787273-
    52 00000054 746F722E0A00       
    53                                  
    54 0000005A 546865207873617665-     unsupportedmessage db "The xsave and xrstor instructions are not supported by this CPU.  No data will be backed up.", 10,
    54 00000063 20616E642078727374-
    54 0000006C 6F7220696E73747275-
    54 00000075 6374696F6E73206172-
    54 0000007E 65206E6F7420737570-
    54 00000087 706F72746564206279-
    54 00000090 207468697320435055-
    54 00000099 2E20204E6F20646174-
    54 000000A2 612077696C6C206265-
    54 000000AB 206261636B65642075-
    54 000000B4 702E0A             
    55 000000B7 557365206F74686572-                        db "Use other strategies for backing up data.", 10, 0
    55 000000C0 207374726174656769-
    55 000000C9 657320666F72206261-
    55 000000D2 636B696E6720757020-
    55 000000DB 646174612E0A00     
    56                                  
    57 000000E2 5468652070726F6772-     firstvalues db "The program will assign 3 arbitrary values to 3 selected xmm registers as follows:",10,0
    57 000000EB 616D2077696C6C2061-
    57 000000F4 737369676E20332061-
    57 000000FD 726269747261727920-
    57 00000106 76616C75657320746F-
    57 0000010F 20332073656C656374-
    57 00000118 656420786D6D207265-
    57 00000121 676973746572732061-
    57 0000012A 7320666F6C6C6F7773-
    57 00000133 3A0A00             
    58 00000136 5468652070726F6772-     backup db "The program will now back all registers (except GPRs) by using xsave",10,0
    58 0000013F 616D2077696C6C206E-
    58 00000148 6F77206261636B2061-
    58 00000151 6C6C20726567697374-
    58 0000015A 657273202865786365-
    58 00000163 707420475052732920-
    58 0000016C 6279207573696E6720-
    58 00000175 78736176650A00     
    59 0000017C 5468652070726F6772-     secondvalues db "The program is assigning 3 new values to those registers as follows",10,0
    59 00000185 616D20697320617373-
    59 0000018E 69676E696E67203320-
    59 00000197 6E65772076616C7565-
    59 000001A0 7320746F2074686F73-
    59 000001A9 652072656769737465-
    59 000001B2 727320617320666F6C-
    59 000001BB 6C6F77730A00       
    60                                  
    61 000001C1 5468652070726F6772-     restoreall db "The program will now restore the original values by use of xrstor", 10,
    61 000001CA 616D2077696C6C206E-
    61 000001D3 6F7720726573746F72-
    61 000001DC 6520746865206F7269-
    61 000001E5 67696E616C2076616C-
    61 000001EE 756573206279207573-
    61 000001F7 65206F662078727374-
    61 00000200 6F720A             
    62 00000203 54686520726573746F-                db "The restored values are these:",10,0
    62 0000020C 7265642076616C7565-
    62 00000215 732061726520746865-
    62 0000021E 73653A0A00         
    63                                  
    64 00000223 786D6D35203D202537-     threenumberform db "xmm5 = %7.4lf, xmm10 = %7.4lf, xmm14 = %7.4lf",10,10,0
    64 0000022C 2E346C662C20786D6D-
    64 00000235 3130203D2025372E34-
    64 0000023E 6C662C20786D6D3134-
    64 00000247 203D2025372E346C66-
    64 00000250 0A0A00             
    65                                  
    66 00000253 546869732070726F67-     goodbye db "This program will now return to the driver.  Have a nice day.", 10, 0
    66 0000025C 72616D2077696C6C20-
    66 00000265 6E6F77207265747572-
    66 0000026E 6E20746F2074686520-
    66 00000277 6472697665722E2020-
    66 00000280 486176652061206E69-
    66 00000289 6365206461792E0A00 
    67                                  
    68                                  segment .bss                                      ;Place un-initialized data here.
    69                                  
    70                                  segment .text                                     ;Place executable instructions in this segment.
    71                                  _xsavexrstormain:                                  ;Entry point.  Execution begins here.
    72                                  
    73                                  ;=========== Back up all the integer registers used in this program =======================================================
    74                                  ;Omitted from back up are rax, rip.
    75 00000000 55                      push       rbp                                    ;Save a copy of the stack base pointer
    76 00000001 4889E5                  mov        rbp, rsp                               ;We do this in order to be 100% compatible with C and C++.
    77 00000004 53                      push       rbx                                    ;Back up rbx
    78 00000005 51                      push       rcx                                    ;Back up rcx
    79 00000006 52                      push       rdx                                    ;Back up rdx
    80 00000007 56                      push       rsi                                    ;Back up rsi
    81 00000008 57                      push       rdi                                    ;Back up rdi
    82 00000009 4150                    push       r8                                     ;Back up r8
    83 0000000B 4151                    push       r9                                     ;Back up r9
    84 0000000D 4152                    push       r10                                    ;Back up r10
    85 0000000F 4153                    push       r11                                    ;Back up r11
    86 00000011 4154                    push       r12                                    ;Back up r12
    87 00000013 4155                    push       r13                                    ;Back up r13
    88 00000015 4156                    push       r14                                    ;Back up r14
    89 00000017 4157                    push       r15                                    ;Back up r15
    90 00000019 9C                      pushf                                             ;Back up rflags
    91                                  
    92                                  ;=========== Show the welcome message =====================================================================================
    93                                  
    94 0000001A B800000000              mov qword  rax, 0                                 ;Zero indicates no data from SSE will be outputted.
    95 0000001F 48BF-                   mov        rdi, welcomemessage                    ;"Welcome to xsave and xrstor."
    95 00000021 [0000000000000000] 
    96 00000029 E8(00000000)            call       _printf                                 ;Display the message using library function
    97                                  
    98                                  ;=========== Show the intent message ======================================================================================
    99 0000002E B800000000              mov qword  rax, 0                                 ;Zero indicates no data from SSE will be outputted.
   100 00000033 48BF-                   mov        rdi, intentmessage                     ;"This program will demonstrate the use of xsave and xrstor."
   100 00000035 [1E00000000000000] 
   101 0000003D E8(00000000)            call       _printf                                 ;Display the message using library function
   102                                  
   103                                  ;=========== Test the current machine to determine if it supports xsave and xrstor. =======================================
   104 00000042 B801000000              mov        rax,1
   105 00000047 0FA2                    cpuid
   106 00000049 4881E100000004          and        rcx,0x0000000004000000
   107 00000050 4883F900                cmp        rcx, 0
   108 00000054 0F8472010000            je         notsupported
   109                                  
   110 0000005A B800000000              mov rax,0
   111 0000005F 48BF-                   mov rdi,firstvalues
   111 00000061 [E200000000000000] 
   112 00000069 E8(00000000)            call _printf
   113                                  
   114                                  ;=========== Set up some values in 3 registers of SSE =====================================================================
   115 0000006E 48B800000000000000-     mov        rax, 0x4000000000000000      ;1.0
   115 00000077 40                 
   116 00000078 50                      push       rax
   117 00000079 F20F102C24              movsd      xmm5, [rsp]
   118 0000007E 58                      pop        rax
   119                                  
   120 0000007F 48B800000000000030-     mov        rax, 0x4030000000000000      ;16.0
   120 00000088 40                 
   121 00000089 50                      push       rax
   122 0000008A F2440F101424            movsd      xmm10, [rsp]
   123 00000090 58                      pop        rax
   124                                  
   125 00000091 48B80000000000008E-     mov        rax, 0x408E000000000000      ;960.0
   125 0000009A 40                 
   126 0000009B 50                      push       rax
   127 0000009C F2440F103424            movsd      xmm14, [rsp]
   128 000000A2 58                      pop        rax
   129                                  
   130                                  ;Now there are values in xmm5, xmm10, and xmm14.  Let's display those values.
   131 000000A3 B803000000              mov rax,3
   132 000000A8 F20F10C5                movsd xmm0,xmm5
   133 000000AC F2410F10CA              movsd xmm1,xmm10
   134 000000B1 F2410F10D6              movsd xmm2,xmm14
   135 000000B6 48BF-                   mov rdi,threenumberform
   135 000000B8 [2302000000000000] 
   136 000000C0 E8(00000000)            call _printf
   137                                  
   138 000000C5 B800000000              mov rax,0
   139 000000CA 48BF-                   mov rdi,backup
   139 000000CC [3601000000000000] 
   140 000000D4 E8(00000000)            call _printf
   141                                  
   142 000000D9 B800000000              mov rax,0
   143 000000DE 48BF-                   mov rdi,secondvalues
   143 000000E0 [7C01000000000000] 
   144 000000E8 E8(00000000)            call _printf
   145                                  
   146                                  ;========== Perform a back up using xsave =================================================================================
   147                                  ;Here is the setup for calling xsave
   148 000000ED B80D000000              mov        rax, 0x000000000000000d                ;Place 13 in rax.  This number is provided in the Intel manual
   149 000000F2 B900000000              mov        rcx, 0                                 ;0 is parameter for subfunction 0, also found in the Intel manual
   150 000000F7 0FA2                    cpuid                                             ;Obtain information about the cpu
   151                                  ;Now rcx hold the number of bytes needed to store all the data in all the components: FPU,SSE,AVX
   152                                  
   153 000000F9 4829CC                  sub rsp, rcx                                      ;Create space on the stack for all the data to be backed up
   154 000000FC 4889E0                  mov rax, rsp
   155 000000FF 4899                    cqo
   156 00000101 41B840000000            mov r8,64
   157 00000107 49F7F0                  div r8
   158                                  ;The remainder, rdx, is important.  By subtracting rdx from rsp then rsp will be on a 64-byte boundary
   159 0000010A 4829D4                  sub rsp, rdx
   160 0000010D 52                      push rdx                      ;Save this number for later use.  The 64-byte boundary is at rsp+8.
   161 0000010E B80D000000              mov        rax, 0x000000000000000d
   162 00000113 B900000000              mov        rcx, 0
   163 00000118 0FA2                    cpuid
   164 0000011A 0FAE642408              xsave      [rsp+1*8]          ;All data have been copied to the stack starting at rsp+8, which is a 64-byte boundary
   165                                  
   166                                  ;=========== The back up using xsave is complete ==========================================================================
   167                                  
   168                                  
   169                                  
   170                                  
   171                                  
   172                                  
   173                                  
   174                                  
   175                                  
   176                                  ;=========== Begin the intended purpose of this module ====================================================================
   177                                  
   178                                  ;This is the region where the working source code for this function belongs.  The programmer may use and modify
   179                                  ;any registers
   180                                  
   181                                  ;Now let's change the values in those three registers
   182 0000011F 48B8000000000000F0-     mov        rax, 0x3FF0000000000000      ;1.0
   182 00000128 3F                 
   183 00000129 50                      push       rax
   184 0000012A F20F102C24              movsd      xmm5, [rsp]
   185 0000012F 58                      pop        rax
   186                                  
   187 00000130 48B8000000000000D0-     mov        rax, 0x3FD0000000000000      ;0.25
   187 00000139 3F                 
   188 0000013A 50                      push       rax
   189 0000013B F2440F101424            movsd      xmm10, [rsp]
   190 00000141 58                      pop        rax
   191                                  
   192 00000142 48B8000000000000BE-     mov        rax, 0x3FBE000000000000      ;0.1172
   192 0000014B 3F                 
   193 0000014C 50                      push       rax
   194 0000014D F2440F103424            movsd      xmm14, [rsp]
   195 00000153 58                      pop        rax
   196                                  
   197                                  ;Now confirm the values stored in the three selected registers
   198 00000154 6A00                    push qword 0                            ;As usual get on the 16-byte boundary
   199 00000156 B803000000              mov rax,3
   200 0000015B F20F10C5                movsd xmm0,xmm5
   201 0000015F F2410F10CA              movsd xmm1,xmm10
   202 00000164 F2410F10D6              movsd xmm2,xmm14
   203 00000169 48BF-                   mov rdi, threenumberform
   203 0000016B [2302000000000000] 
   204 00000173 E8(00000000)            call _printf
   205 00000178 4883C408                add rsp, 8                              ;Same as pop a quadword from the stack
   206                                  
   207                                  ;=========== End of the intended purpose of this module ===================================================================
   208                                  
   209                                  
   210                                  
   211                                  
   212                                  
   213                                  
   214                                  
   215                                  
   216                                  
   217                                  
   218                                  
   219                                  
   220                                  
   221                                  ;========== Next restore the original values using xrstor =================================================================
   222 0000017C B800000000              mov rax,0
   223 00000181 48BF-                   mov rdi,restoreall
   223 00000183 [C101000000000000] 
   224 0000018B E8(00000000)            call _printf
   225                                  
   226                                  ;Perform the setup block
   227 00000190 B80D000000              mov        rax, 0x000000000000000d
   228 00000195 B900000000              mov        rcx, 0
   229 0000019A 0FA2                    cpuid
   230 0000019C 0FAE6C2408              xrstor     [rsp+8]    ;Restore the original data to all the registers by reading it from rsp+8
   231                                  
   232 000001A1 5A                      pop        rdx                          ;Recover the number of bytes subtracted from the top of stack
   233 000001A2 4801D4                  add        rsp, rdx
   234 000001A5 4801CC                  add        rsp, rcx                     ;Remove from the stack the area used to store state components 0, 1, and 2.
   235                                  
   236                                  ;The stack is now in the state it was before xsave was called.
   237                                  ;========== End of restoring the original values to all the registers (except GPRs) =======================================
   238                                  
   239                                  ;Let's find out if our three selected registers have their original values.
   240 000001A8 B803000000              mov rax,3
   241 000001AD F20F10C5                movsd xmm0,xmm5
   242 000001B1 F2410F10CA              movsd xmm1,xmm10
   243 000001B6 F2410F10D6              movsd xmm2,xmm14
   244 000001BB 48BF-                   mov rdi, threenumberform
   244 000001BD [2302000000000000] 
   245 000001C5 E8(00000000)            call _printf
   246                                  
   247 000001CA EB16                    jmp conclusion
   248                                  
   249                                  notsupported:
   250 000001CC B800000000              mov        rax, 0                                 ;Make sure printf does not attempt to output any floating point values.
   251 000001D1 48BF-                   mov        rdi, unsupportedmessage                ;"The xsave and xrstor instructions are not supported by this CPU...."
   251 000001D3 [5A00000000000000] 
   252 000001DB E8(00000000)            call       _printf
   253 000001E0 EB1A                    jmp        done
   254                                  
   255                                  conclusion:
   256 000001E2 6A00                    push qword 0                                      ;Make rsp divisible by 16 for the benefit of printf
   257 000001E4 B800000000              mov qword  rax, 0                                 ;Zero indicates no data from SSE will be outputted.
   258 000001E9 48BF-                   mov        rdi, goodbye                           ;"This program will now return to the driver.  Have a nice day."
   258 000001EB [5302000000000000] 
   259 000001F3 E8(00000000)            call       _printf                                 ;Display the message using library function
   260 000001F8 4883C408                add        rsp,8                                  ;Reverse the push of 5 lines earlier.
   261                                  
   262                                  done:
   263                                  ;=========== Now cleanup and return to the caller =========================================================================
   264                                  
   265 000001FC 9D                      popf                                              ;Restore rflags
   266 000001FD 415F                    pop        r15                                    ;Restore r15
   267 000001FF 415E                    pop        r14                                    ;Restore r14
   268 00000201 415D                    pop        r13                                    ;Restore r13
   269 00000203 415C                    pop        r12                                    ;Restore r12
   270 00000205 415B                    pop        r11                                    ;Restore r11
   271 00000207 415A                    pop        r10                                    ;Restore r10
   272 00000209 4159                    pop        r9                                     ;Restore r9
   273 0000020B 4158                    pop        r8                                     ;Restore r8
   274 0000020D 5F                      pop        rdi                                    ;Restore rdi
   275 0000020E 5E                      pop        rsi                                    ;Restore rsi
   276 0000020F 5A                      pop        rdx                                    ;Restore rdx
   277 00000210 59                      pop        rcx                                    ;Restore rcx
   278 00000211 5B                      pop        rbx                                    ;Restore rbx
   279 00000212 5D                      pop        rbp                                    ;Restore rbp
   280                                  
   281 00000213 48C7C0FBFFFFFF          mov qword  rax, -5                                ;Send the -5 to the caller program.
   282                                  
   283 0000021A C3                      ret
   284                                  ;====== The End ===========================================================================================================
   285                                  
   286                                  ;To computer science students:
   287                                  ;There is a matter of nice etiquete involved here.  When we assembly programmers create a function to be called by 
   288                                  ;functions written by others we have the responsibility to leave the playing field in the same state in which we found it.
   289                                  ;Here is an example for another part of life: when you and your friends have picnic in a city park and when you finish you are
   290                                  ;responsible to pick up your trash and leave the area as clean as you found it.  That principle carries over to assembly 
   291                                  ;programming.  When we create a function in assembly we want to put the data back in the same places where we found it.
   292                                  ;That is the reason we do a lot of pushes at the beginning of a function and a lot of pops at the end of the function.
   293                                  ;That responsibility is also way we should xsave other registers are the beginning of a function and xrstor them at the
   294                                  ;end of the function.  Will all this backup and restore really be enforced in our class?  Probably not.  Right now your 
   295                                  ;professor would just like to see nice modular working programs.
   296                                  
   297                                  
   298                                  
   299                                  
   300                                  
   301                                  
   302                                  
   303                                  
   304                                  
   305                                  
   306                                  
   307                                  
   308                                  ;Lesson learned:  During development of this program the author learned that printf will change 
   309                                  ;the value stored in xmm9.  That means xmm9 must be individually backedup before any call to printf
   310                                  ;and restored after calling printf.
   311                                  
   312                                  
   313                                  
   314                                  
   315                                  
   316                                  
   317                                  
   318                                  ;====== Secondary information not related to backing up xmm registers ==============================================
   319                                  ;The following pair of instructions writes information about the cpu to rcx.
   320                                  ;       mov rax,1
   321                                  ;       cpuid
   322                                  ;The contents of rcx can be checked to determine the presence of hardware and instructions according to 
   323                                  ;the following table.  If the bit in the left column is 1 then the hardware written to the right is
   324                                  ;present in the processor.
   325                                  ;   bit # | Outcome
   326                                  ;   ------|-----------------------
   327                                  ;       0 | SSE3 supported
   328                                  ;       9 | SSSE3 supported
   329                                  ;      19 | SSSE4.1 supported
   330                                  ;      20 | SSSE4.2 supported
   331                                  ;      26 | xsave/xrstor supported
   332                                  ;      28 | AVX supported
   333                                  ;
   334                                  ;Of interest to this program is the fact that bit #26 must be 1 in order for software to execute either
   335                                  ;of the xsave or xrstor instruction.
